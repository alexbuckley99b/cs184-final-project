<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>CS184 Final Report</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
<style>
    h6 {
        font-weight: bold;
    }
</style>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />

</head>
<body>
    <div class="container">
        <h2>CS184 Final Report</h2>
        <h5><b>Font Rasterization:</b> Kyle Wallace, Raiya Choudhuri, Scott Durand, Alex Buckley</h5>
        <p></p>
        <h6>Abstract</h6>
        <p>In this project, we worked on rasterizing fonts from TrueTypeFont(.ttf) files. These files specify a font by specifying spacing between glyphs, providing the control points of lines and Bezier curves that make up each glyph, and more. To accomplish font rasterization, we first added support for the CS 184 Rasterizer project to parse .ttf files and draw Bezier curves. We then implemented an algorithm to rasterize flood-filled glyphs, and modified it to work with supersampling. Finally, we added the ability to map textures onto the glyphs and optimized our code. </p>

        <div class="divider"></div>

        <h6>Technical Approach</h6>
        <p><b>Processing TrueType Files and Displaying Results</b></p>
        <p>[Summary of your technical approach, techniques used, algorithms implemented. Highlight how your approach varied from the references used, the unique decisions you made and why.]
        <br />[A description of problems encountered and how you tackled them.]
        <br />[A description of lessons learned.]</p>

        <p><b><br />Rasterizing Glyph Outlines via Bezier Curves</b></p>
        <p> One method of text rasterization is through the glyph outlines created by the lines and curves. In order to rasterize these outlines, after the TrueType file is parsed into a set of BezierCurve objects, each of these objects are passed into RasterizerImp::rasterize_bc. If the curve consists of one or two points, rasterize_point() or rasterize_line() are called. Otherwise, for a range of t values between 0 and 1 (incrementing by .005 gives a smooth enough result for text unless it is very large) the point on the curve corresponding to that t value is calculated iteratively by linearly interpolating each consecutive pair of points until there is only one point left. This value is then rounded down to the nearest integer to get a pixel coordinate and added to the pixel buffer using the fill_pixel method.  </p>

        <p> One problem encountered was adjusting the Bezier curve calculation to be iterative instead of recursive. In project 2, we implemented the calculation recursively. However, since the calculation is being done multiple times within a larger function (rasterize_bc), a recursive call does not work. An iterative solution was much cleaner. Another problem was determining the appropriate step size for incrementing t. Too large and there are gaps in the outline, but the smaller the step size, the longer it takes to rasterize an outline. .005 is a good balance between the two - it does not result in gaps unless letters are very large, but is not so small that rasterization takes forever. </p>

        <p><b><br />Rasterizing Flood-Filled Text</b></p>
        <p> To rasterize flood-filled text, we utilized an algorithm that calculated intersections between each row in the pixel buffer and the Bezier curves for each glyph in the text. Since the .ttf file specifies the control points of the Bezier curve, we use the Bezier curve equation to solve for the t parameter associated with the y-position of the row.  The equation can then be used to solve for the x-position of the intersection using the newfound t parameter and the control points. </p>
        <figure>
        <img src="images/equations.png" width="100%">
        <figcaption>from <a href="https://javascript.info/bezier-curve">https://javascript.info/bezier-curve</a></figcaption>    
        </figure>    
        <p>We do this with the y-value of a row and every Bezier curve in the text to accumulate a set of intersection points, and then sort them from left to right. From there, every other pair of intersections can be filled, since those will represent being "inside" of a glyph. This process is repeated for every row in the buffer to create flood-filled text. </p>
        <p>Our approach likely differs from the FreeType library and other library's approaches to rasterization, which utilize extra steps to ensure clarity through techniques such as grid alignment. These extra procedures seemed complex and not well-documented, and so we thought it would be better to take a simpler approach.</p>
        <p>One of the problems encountered during flood-filling was that one source stated that .ttf files specified only quadratic Bezier curves and lines, which are easy to solve, but upon actually working with them, we discovered that they can include cubic Beziers as well. The <a href="https://math.vanderbilt.edu/schectex/courses/cubic/">formula</a> for solving cubic polynomials is tedious to implement, and instead we looked at adding a <a href="http://math.ivanovo.ac.ru/dalgebra/Khashin/poly/index.html">library</a> for solving polynomial equations. A good lesson learned was that sometimes your sources can be incomplete or incorrect, and working with real data often involves surprises. </p>

        <p><b><br />Anti-aliasing via Supersampling</b></p>
        
        <p>To create anti-aliased rasterizations, we took advantage of the work done in project 1 to add anti-aliasing via supersampling. Some elements, like resolving samples to the frame buffer or resizing the sample buffer, were already complete and didn't need to be changed, which made this approach convenient. The FreeType library provides several methods of anti-aliasing, including a default <a href="https://www.freetype.org/freetype2/docs/ft2faq.html#other-antialias">"high speed, low memory"</a> algorithm, and <a href="https://www.freetype.org/freetype2/docs/reference/ft2-lcd_rendering.html">LCD filtering</a>. Our approach of supersampling is more memory-intensive and likely slower than these approaches, however, it was more straightforward and finding documentation on these alternate techniques was difficult.</p>
        
        <p>The technique used to fill the supersampled sample buffer would need to be altered from the one used to flood-fill text. The slightly modified algorithm would look at each pixel row of the sample buffer, then look at each row of supersamples within that row, calculate intersections at the sub-pixel y-position of the supersample, and fill samples between pairs of supersampled intersections. The overall logic of the algorithm remained the same, however the complexity arose from iterating correctly and making buffer accesses correctly. </p>

        <p>Several problems were encountered while implementing supersampling. The first was trying to comprehend the existing code from the project 1 implementation, as the team member's code we were using had laid out supersamples in the sample buffer and iterated through them differently than the team member who was trying to implement supersampling. Some techniques that helped remedy this situation were drawing out pictures of the supersample layout, printing out the indices of buffer accesses, and reviewing the project spec. These techniques also helped in fixing issues where supersampling did not look correct and it was clear that some accesses were being made incorrectly or some number was being rounded incorrectly. </p>

        <p>Another issue was figuring out the order in which to iterate through supersamples. There were two main options - for each row, iterate through supersamples within each pixel or iterate through each row of supersamples. The first approach seemed pretty naive and simple to implement, but inefficient, whereas the second seemed more complex but ultimately made more sense. Ultimately, the first was implemented to test out the technique and figure out which areas were important for the second approach, and then iterating through rows of supersamples was implemented, with comparisons made to the pixel-by-pixel approach to see where bugs arose and if there were any logical errors. </p>

        <p></p><b><br />Texture Mapping</b></p>
        <p> Implementing texture mapping involved two main problems - reading in PNG files to create the textures, and integrating our Project 1 texture mapping code into our font rasterizer. In order to access PNG files to create textures, the relative path to the PNG must be passed in as an argument on the command line. The lodepng C++ package is used to read that PNG into a vector of pixels. The alpha channel is stripped and a new Texture object is created. This method of reading in PNG files to create textures is adapted from the Project 1 code. This texture is then included as part of each glyph object that is rasterized. The way that the texture is used for mapping is that it is essentially stretched to fit the bounding box of the text, and then sampled using uv coordinates from 0 to 1. When rasterizing a glyph, for each pixel that is supposed to be colored, the color is calculated using the bilinear texture sampling method from Project 1. Bilinear sampling involves sampling the 4 points around the uv coordinate of the pixel, and linearly interpolating them to create a weighted average color for the point. </p>

        <p> The trickiest part of implementing this feature was reading in the PNG file to create the texture and then deciding how to store that texture. Because of the way our font rasterizer stores glyphs, it made more sense to store a pointer to the texture with each individual glyph, rather than as a global variable. </p>

        <p><b><br />Optimizations</b></p>
        <p>[Summary of your technical approach, techniques used, algorithms implemented. Highlight how your approach varied from the references used, the unique decisions you made and why.]
        <br />[A description of problems encountered and how you tackled them.]
        <br />[A description of lessons learned.]</p>
        
        <div class="divider"></div>

        <h6>Results</h6>
        <p>[Your final images, animations, video of your system (whichever is relevant). You can include results that you think show off what you built but that you did not have time to go over on presentation day.]</p>

        <p><b><br />Flood-filled text</b></p>
        <figure>
        <img src="images/floodfill.PNG" width="50%">
        </figure> 

        <p><b><br />Texture mapping</b></p>
        <figure>
        <img src="images/texture_mapping.PNG" width="50%">
        </figure> 

        <p><b><br />Comparison to real text</b></p>
        <figure>
        <img src="images/comparison.PNG" width="50%">
        <figcaption> Comparison of our rasterized text to text from Google Slides. Our text is in the green boxes. </figcaption>
        </figure> 

        <div class="divider"></div>

        <h6>References</h6>
        <p>[References.]</p>

        <div class="divider"></div>

        <h6>Contributions From Each Team Member</h6>
        <p> Kyle Wallace </p>
        <p> Raiya Choudhuri </p>
        <p> Scott Durand </p>
        <p> Alex Buckley - Bezier curve calculation, rasterization of glyph outlines, reading PNG files, texture mapping, videos.</p>

        <div class="divider"></div>

        <h6>Video</h6>
        <!-- Replace the URL in the src -->
        <iframe width="560" height="315" src="https://www.youtube.com/embed/HjO8aAzMgHM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
        
        <div class="divider"></div>

        <h6>Slides</h6>
        <!-- Add the slides URL in the href -->
        <p><a href="https://docs.google.com/presentation/d/1oFR8T_QCcM2wz8iYrW4CdIzfXCMRY-HIcSTnDIBTqyQ/">Slides available here</a></p>

        <figure>
        <img src="images/thank_you.PNG" width="100%">
        </figure> 
    </div>
</body>